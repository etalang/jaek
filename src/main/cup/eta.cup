import java_cup.runtime.*;
import ast.*;

/* Preliminaries to set up and use the scanner.  */
//init with {: scanner.init();              :};
scan with {: return getScanner().next_token(); :};

/* Terminals */
terminal String IDENTIFIER;
terminal STRING_LITERAL;
terminal CHARACTER_LITERAL;
terminal INTEGER_LITERAL;
terminal TRUE, FALSE;
terminal INT, BOOL;

terminal IF, ELSE, WHILE, RETURN, USE, LENGTH, PLUS, MINUS, TIMES, HIGHTIMES,
  DIVIDE, MODULO, NOT, LT, LEQ, GT, GEQ, AND, OR, EQUALS, EQB, NEQB,
  OPEN_BRACKET, CLOSE_BRACKET, OPEN_PAREN, CLOSE_PAREN, OPEN_BRACE, CLOSE_BRACE,
  COLON, COMMA, SEMICOLON, UNDERSCORE, UMINUS;

terminal INTERFACE, PROGRAM;

/* Nonterminals */
nonterminal Program program;
nonterminal Imports imports;
nonterminal Use use;
nonterminal Definitions defns;
nonterminal Definition definition;
nonterminal MethodInterface abs_meth;
nonterminal Method method;
nonterminal Declaration decl;
nonterminal Declaration globalDecl;
nonterminal Declarations decls;
nonterminal TypeList typelst;
nonterminal Type type;

nonterminal file, interface, globalAssign;
nonterminal assign, target, targets;
nonterminal statement, statementlst, if, while, fnblock, block, elseopt, semi;
nonterminal binop, unop, expr, fncall, arrayinit;
nonterminal return, vallst, bracketlst, nullbrackets, idxlst;

/* Precedences */
precedence left OR;
precedence left AND;
precedence left EQB, NEQB;
precedence left LT, LEQ, GT, GEQ;
precedence left PLUS, MINUS;
precedence left TIMES, HIGHTIMES, DIVIDE, MODULO;
precedence left UMINUS, NOT;
precedence left COMMA, OPEN_BRACKET, CLOSE_BRACKET, ELSE;

/* Grammar Definition */
//file            ::= INTERFACE interface {: System.out.println("got here"); :}
//                    | PROGRAM program;
//interface       ::= | abs_meth interface ;
start with program;

program         ::= imports:Is defns:Ds {: RESULT = new Program(Is, Ds); :};
imports         ::= use:u imports:It {: It.prependImport(u); RESULT = It; :}
                    | {: RESULT = new Imports(); :}                    ;
use             ::= USE IDENTIFIER:id semi {: RESULT = new Use(id); :};
defns           ::= definition:d defns:Dt {: Dt.prependDefn(d); RESULT = Dt; :}
                    | {: RESULT = new Definitions(); :};
definition      ::= method:m {: RESULT = m; :}
                | globalDecl:gD semi {: RESULT = gD; :}
                | assign:a semi {: RESULT = a; :};
abs_meth        ::= IDENTIFIER:id OPEN_PAREN decls:Ds CLOSE_PAREN COLON typelst:Ts
                    {: RESULT = new MethodInterface(id, Ds, Ts); :}
                    | IDENTIFIER:id OPEN_PAREN decls:Ds CLOSE_PAREN
                    {: RESULT = new MethodInterface(id, Ds, new TypeList()); :}
                    | IDENTIFIER:id OPEN_PAREN CLOSE_PAREN COLON typelst:Ts
                    {: RESULT = new MethodInterface(id, new Declarations(), Ts); :}
                    | IDENTIFIER:id OPEN_PAREN CLOSE_PAREN
                    {: RESULT = new MethodInterface(id, new Declarations(), new TypeList()); :};
decls           ::= decl:d {: Declarations Ds = new Declarations(); Ds.prependDecl(d); RESULT = Ds; :}
                    | decl:d COMMA decls:Ds {: Ds.prependDecl(d); RESULT = Ds; :};
arrayinit       ::= IDENTIFIER:id COLON bracketlst;
bracketlst      ::= OPEN_BRACKET expr CLOSE_BRACKET |
                    OPEN_BRACKET expr CLOSE_BRACKET bracketlst |
                    OPEN_BRACKET expr CLOSE_BRACKET n;
nullbrackets    ::= OPEN_BRACKET CLOSE_BRACKET |
                    OPEN_BRACKET CLOSE_BRACKET nullbrackets;
globalDecl      ::= IDENTIFIER:id COLON type:t {: RESULT = new Declaration(id, t); :};
decl            ::= globalDecl:gD {:RESULT = gD;:}
                    | arrayinit:a {:RESULT = a;:} ;
globalAssign    ::= globalTargets EQUALS litLst;
assign          ::= targets EQUALS vallst;
method          ::= abs_meth:am fnblock:b {: RESULT = new Method(am, b); :};
typelst         ::= type |
                    type COMMA typelst;
statementlst    ::= statement | statement statementlst;
if              ::= IF expr block elseopt |
                    IF OPEN_PAREN expr CLOSE_PAREN block elseopt;
while           ::= WHILE OPEN_PAREN expr CLOSE_PAREN block |
                    WHILE expr block;
fnblock         ::= OPEN_BRACE statementlst CLOSE_BRACE |
                    OPEN_BRACE statementlst return CLOSE_BRACE |
                    OPEN_BRACE return CLOSE_BRACE |
                    OPEN_BRACE CLOSE_BRACE;
block           ::= statement |
                    fnblock;
statement       ::= if |
                    while |
                    decl semi |
                    assign semi |
                    fncall semi;
fncall          ::= IDENTIFIER OPEN_PAREN vallst CLOSE_PAREN |
                    IDENTIFIER OPEN_PAREN CLOSE_PAREN;
elseopt         ::= | ELSE block;
unop            ::= MINUS %prec UMINUS | // cannot differentiate identical token but need diff prec
                    NOT;
binop           ::= PLUS |
                    MINUS |
                    TIMES |
                    HIGHTIMES |
                    DIVIDE |
                    MODULO |
                    LT |
                    LEQ |
                    GT |
                    GEQ |
                    EQB |
                    NEQB |
                    AND |
                    OR;
return          ::= RETURN semi |
                    RETURN vallst semi ;
vallst         ::= expr |
                    expr COMMA vallst;
type            ::= BOOL {:RESULT = BOOL();:}
                    | INT {:RESULT = INT();:}
                    | type:t  OPEN_BRACKET CLOSE_BRACKET {:RESULT = Array(t);:}; // I think this is problematic and we should fix
expr            ::= expr binop expr |
                    unop expr |
                    IDENTIFIER |
                    fncall |
                    STRING_LITERAL |
                    INTEGER_LITERAL:l |
                    CHARACTER_LITERAL |
                    FALSE {:RESULT = BoolLit(false);:} |
                    TRUE {:RESULT = BoolLit(true);:} |
                    OPEN_BRACE vallst CLOSE_BRACE |
                    IDENTIFIER idxlst |
                    LENGTH OPEN_PAREN expr CLOSE_PAREN;
idxlst          ::= OPEN_BRACKET expr CLOSE_BRACKET |
                    OPEN_BRACKET expr CLOSE_BRACKET idxlst;
target          ::= decl |
                    UNDERSCORE |
                    IDENTIFIER |
                    IDENTIFIER idxlst; // array element
targets         ::= target |
                    target COMMA targets;
semi            ::= SEMICOLON |
                    ;
