import java_cup.runtime.*;
import ast.*;
import kotlin.collections.CollectionsKt;
import kotlin.jvm.internal.markers.*;
import java.util.*;

scan with {: return getScanner().next_token(); :};

/* Terminals */
terminal String IDENTIFIER;
terminal String STRING_LITERAL;
terminal Character CHARACTER_LITERAL;
terminal String INTEGER_LITERAL;
terminal TRUE, FALSE;
terminal INT, BOOL;
terminal BinaryOp.Operation PLUS, MINUS, TIMES, HIGHTIMES, DIVIDE, MODULO, NOT, LT, LEQ, GT, GEQ, AND, OR, EQUALS, EQB, NEQB;

terminal IF, ELSE, WHILE, RETURN, USE, LENGTH,
  OPEN_BRACKET, CLOSE_BRACKET, OPEN_PAREN, CLOSE_PAREN, OPEN_BRACE, CLOSE_BRACE,
  COLON, COMMA, SEMICOLON, UNDERSCORE, UMINUS;

terminal INTERFACE, PROGRAM;

/* Nonterminals */
nonterminal Eta file;
nonterminal Interface interface;
nonterminal Program program;
nonterminal ArrayList<Use> imports;
nonterminal Use use;
nonterminal ArrayList<Definition> allDefinitions;
nonterminal ArrayList<Definition> definition;
nonterminal Method methodHeader;
nonterminal Method method;
nonterminal GlobalDecl globalDecl;
nonterminal ArrayList<GlobalDecl> globalDecls;
nonterminal Definition globalMultiDeclaration;
nonterminal ArrayList<Type> typelst;
nonterminal Primitive primType;
nonterminal Type type;
nonterminal Literal primitiveLiteral;
nonterminal ArrayList<Literal> primLitLst;
nonterminal Statement.If if;
nonterminal Statement.While while;
nonterminal Statement return;
nonterminal Expr expr;
nonterminal ArrayList<GlobalDecl> methodArgs;
nonterminal Statement returnableBlock, block;
nonterminal ArrayList<Statement> statementList;
nonterminal Statement statement;
nonterminal Statement.Block elseOptional; // might have to add empty list in empty case to type check?
nonterminal Statement.Procedure procedureCall;
nonterminal Expr.FunctionCall functionCall;
nonterminal MultiAssignBuilder multiAssign;
nonterminal ArrayList<Expr> exprList;
nonterminal Statement multiDeclOrArrayInit;
nonterminal ArrayInit arrayinit, arrayNonBlank;

nonterminal methodArg;
nonterminal assignable, assignables;
nonterminal varDecl;
//nonterminal varDeclOrArrayInit;
nonterminal semi;
nonterminal BinaryOp.Operation binop;
nonterminal UnaryOp.Operation unop;
nonterminal arrayAccess;

/* Precedences */
precedence left OR;
precedence left AND;
precedence left EQB, NEQB;
precedence left LT, LEQ, GT, GEQ;
precedence left PLUS, MINUS;
precedence left TIMES, HIGHTIMES, DIVIDE, MODULO;
precedence left UMINUS, NOT;
precedence left COMMA, OPEN_BRACKET, CLOSE_BRACKET, ELSE;

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Root */
start with file;
file            ::= INTERFACE interface:It                      {: RESULT = It; :}
                    | PROGRAM program:P                         {: RESULT = P;  :};
interface       ::= methodHeader:am interface:it                {: ArrayList<Method> ml = it.getMethodHeaders(); ml.add(0, am); RESULT = new Interface(ml); :}
                    |                                           {: RESULT = new Interface(new ArrayList<Method>());:};
program         ::= imports:Is allDefinitions:Ds                {: RESULT = new Program(Is, Ds); :};

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Imports */
imports         ::= use:u imports:It                            {: It.add(0, u); RESULT = It; :}
                    |                                           {: RESULT = new ArrayList<Use>(); :};
use             ::= USE IDENTIFIER:id semi                      {: RESULT = new Use(id); :};

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Top Level Declarations */
allDefinitions  ::= definition:d allDefinitions:Dt              {: Dt.addAll(d); RESULT = Dt; :} //could be sketch
                    |                                           {: RESULT = new ArrayList<Definition>(); :};
definition      ::= method:m                                    {: RESULT = ParseUtil.singleton(m); :}
                    | globalMultiDeclaration:dc semi            {: RESULT = ParseUtil.singleton(dc); :};

/* =============> Global Variables <============= */
// a : int[6] ILLEGAL
// b : int[] = 5
globalMultiDeclaration ::= globalDecls:gD                      {: RESULT = new GlobalDeclarationBuilder(gD, null); :}
                        | globalDecls:gD EQUALS primLitLst:pl  {: RESULT = new GlobalDeclarationBuilder(gD, pl); :};
globalDecls     ::=  globalDecl:d                              {: RESULT = ParseUtil.singleton(d); :}
                    | globalDecl:d COMMA globalDecls:Ds        {: Ds.add(0, d); RESULT = Ds; :};
globalDecl      ::= IDENTIFIER:id COLON type:t                 {: RESULT = new GlobalDecl(id, t); :}; //note this technically allows int[] with an = but whatever

/* =============> [Global] Methods <============= */
methodHeader        ::= IDENTIFIER:id OPEN_PAREN methodArgs:Ds CLOSE_PAREN COLON typelst:Ts  {: RESULT = new Method(id, Ds, Ts); :}
                    | IDENTIFIER:id OPEN_PAREN methodArgs:Ds CLOSE_PAREN                     {: RESULT = new Method(id, Ds, new ArrayList<Type>()); :}
                    | IDENTIFIER:id OPEN_PAREN CLOSE_PAREN COLON typelst:Ts                  {: RESULT = new Method(id, new ArrayList<GlobalDecl>(), Ts); :}
                    | IDENTIFIER:id OPEN_PAREN CLOSE_PAREN                                   {: RESULT = new Method(id, new ArrayList<GlobalDecl>(), new ArrayList<Type>()); :};
methodArg       ::= IDENTIFIER:id COLON type:t ;
methodArgs      ::= methodArg:ma                                                    {::}
                    | methodArg:ma COMMA methodArgs;

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Statements */
statementList   ::= statement:s                                                     {:RESULT = ParseUtil.singleton(s);:}
                    | statement:s statementList:sl                                  {:sl.add(0, s); RESULT = sl;:};
statement       ::= if:i                                                            {: RESULT = i; :}
                    | while:w                                                       {: RESULT = w; :}
                    | multiAssign:a semi                                            {: RESULT = a; :}
                    | multiDeclOrArrayInit:d semi                                   {: RESULT = d; :}
                    | procedureCall:fn semi                                          {: RESULT = fn; :};
if              ::= IF expr:e block:b elseOptional:els                              {: RESULT = new Statement.If(e, b, els); :}
                    | IF OPEN_PAREN expr:e CLOSE_PAREN block:b elseOptional:els     {: RESULT = new Statement.If(e, b, els); :};
while           ::= WHILE OPEN_PAREN expr:e CLOSE_PAREN block:b                     {: RESULT = new Statement.While(e, b); :}
                    | WHILE expr:e block:b                                          {: RESULT = new Statement.While(e, b); :};
block           ::= statement:s                                                     {: RESULT = new Statement.Block(ParseUtil.singleton(s)); :}
                    | returnableBlock:rb                                            {: RESULT = rb; :};
returnableBlock ::= OPEN_BRACE statementList:sLst CLOSE_BRACE                       {: RESULT = new Statement.Block(sLst); :}
                    | OPEN_BRACE statementList:sLst return:r CLOSE_BRACE            {: sLst.add(r); RESULT = new Statement.Block(sLst); :} // is this being added to the end??
                    | OPEN_BRACE return:r CLOSE_BRACE                               {: RESULT = new Statement.Block(ParseUtil.singleton(r)); :};
procedureCall   ::= IDENTIFIER:id OPEN_PAREN exprList:vl CLOSE_PAREN                {: RESULT = new Statement.Procedure(id, vl);:} // these should be statements!
                    | IDENTIFIER:id OPEN_PAREN CLOSE_PAREN                          {: RESULT = new Statement.Procedure(id, new ArrayList<Expr>());:};
elseOptional         ::=
                    | ELSE block:b                                             {: RESULT = ParseUtil.singleton(new Statement.Block(b)); :};
semi            ::= SEMICOLON | ;
return          ::= RETURN semi                                                     {: RESULT = new Statement.Return(new ArrayList<Expr>()); :}
                    | RETURN exprList:exprLst semi                                  {: RESULT = new Statement.Return(exprLst); :};
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Local Variables */

/* =============> [MULTI] No Assignment <============= */
// RESULTS: Declaration No Init OR Array Init
multiDeclOrArrayInit ::= varDecl
                        | arrayinit:ai {:RESULT = ai;:}
                        | varDecl COMMA multiDeclOrArrayInit | arrayinit COMMA multiDeclOrArrayInit;
//varDeclOrArrayInit ::= varDecl | arrayinit;

/* =============> [MULTI] With Assignment <============= */
// includes a = b but also has more ~fun~ stuff with decls like a : int, b = 5, 4
// RESULTS: Declaration + Init (var + []), Assignment (to var and to _)

varDecl         ::= IDENTIFIER:id COLON type:t                     {: RESULT = new VarDecl(id, t); :};
assignable          ::= arrayAccess:e1                                 {: RESULT = e1; :}
                    | varDecl:vd                                   {: RESULT = vd; :}
                    | UNDERSCORE                                   {: RESULT = "TODO"; //TODO :};
assignables         ::= assignable:t                                       {: RESULT = "TODO"; //TODO :}
                    | assignable COMMA assignables                         {: RESULT = "TODO"; //TODO :} ;
multiAssign     ::= assignables:tg EQUALS exprList:exprs               {: RESULT = new MultiAssignBuilder(tg, exprs);:};

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Initializations */
arrayinit       ::= arrayNonBlank:anb                                               {: RESULT = anb;:}
                    | arrayinit:ai OPEN_BRACKET CLOSE_BRACKET                       {: RESULT = new ArrayInit.Dim(ai, null); :};
arrayNonBlank   ::= primType:pt OPEN_BRACKET expr:e CLOSE_BRACKET                   {: RESULT = new ArrayInit.ArrPtr(pt, e); :}
                    | arrayNonBlank:anb OPEN_BRACKET expr:e CLOSE_BRACKET           {: RESULT = new ArrayInit.Dim(anb, e); :};
method          ::= methodHeader:am returnableBlock:b                               {: am.setBody(b); RESULT = am; :};
typelst         ::= type |
                    type COMMA typelst;

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Expressions */
expr            ::= expr:l binop:op expr:r                         {: RESULT = new BinaryOp(op, l, r); :}
                    | unop:op expr:arg                             {: RESULT = new UnaryOp(op, arg); :}
                    | IDENTIFIER:id                                {: RESULT = new Literal.Identifier(id); :} //amazing work
                    | functionCall:fc                              {: RESULT = fc; :}
                    | STRING_LITERAL:s                             {: RESULT = new Literal.StringLit(s); :}
                    | primitiveLiteral:pl                          {: RESULT = pl; :}
                    | OPEN_BRACE exprList:el CLOSE_BRACE           {: RESULT = new Literal.ArrayLit(el); :}  //array literal
                    | expr:e1 OPEN_BRACKET expr:e2 CLOSE_BRACKET   {: RESULT = new Expr.ArrayAccess(e1,e2); :}
                    | LENGTH OPEN_PAREN expr:e CLOSE_PAREN         {: RESULT = e; :};
exprList          ::= expr:e                                       {: RESULT = ParseUtil.singleton(e);  :}
                    | expr:e COMMA exprList:l                      {: l.add(0,e); RESULT = l; :};
primitiveLiteral  ::= INTEGER_LITERAL:n                            {: RESULT = new Literal.IntLit(Long.parseLong(n)); :}
                    | CHARACTER_LITERAL:c                          {: RESULT = new Literal.CharLit(c); :}
                    | FALSE                                        {: RESULT = new Literal.BoolLit(false); :}
                    | TRUE                                         {: RESULT = new Literal.BoolLit(true); :};
primLitLst      ::= primitiveLiteral:pl                            {: RESULT = ParseUtil.singleton(pl); :}
                    | primitiveLiteral:pl primLitLst:pll           {: pll.add(0, pl); RESULT = pll;:};
functionCall    ::= IDENTIFIER:id OPEN_PAREN exprList:vl CLOSE_PAREN  {: RESULT = new Expr.FunctionCall(id, vl);:} // these should be statements!
                    | IDENTIFIER:id OPEN_PAREN CLOSE_PAREN            {: RESULT = new Expr.FunctionCall(id, new ArrayList<Expr>());:};
unop            ::= MINUS %prec UMINUS |                           {: RESULT = UnaryOp.Operation.NEG; :}// cannot differentiate identical token but need diff prec
                    NOT                                            {: RESULT = UnaryOp.Operation.NOT; :}; // need to take expr
binop           ::= PLUS                                           {: RESULT = BinaryOp.Operation.PLUS; :}
                    | MINUS                                        {: RESULT = BinaryOp.Operation.MINUS; :}
                    | TIMES                                        {: RESULT = BinaryOp.Operation.TIMES; :}
                    | HIGHTIMES                                    {: RESULT = BinaryOp.Operation.HIGHTIMES; :}
                    | DIVIDE                                       {: RESULT = BinaryOp.Operation.DIVIDE; :}
                    | MODULO                                       {: RESULT = BinaryOp.Operation.MODULO; :}
                    | LT                                           {: RESULT = BinaryOp.Operation.LT; :}
                    | LEQ                                          {: RESULT = BinaryOp.Operation.LEQ; :}
                    | GT                                           {: RESULT = BinaryOp.Operation.GT; :}
                    | GEQ                                          {: RESULT = BinaryOp.Operation.GEQ; :}
                    | EQB                                          {: RESULT = BinaryOp.Operation.EQB; :}
                    | NEQB                                         {: RESULT = BinaryOp.Operation.NEQB; :}
                    | AND                                          {: RESULT = BinaryOp.Operation.AND; :}
                    | OR                                           {: RESULT = BinaryOp.Operation.OR; :};

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Types */
primType        ::= BOOL                                           {:RESULT = new Primitive.BOOL(); :}
                    | INT                                          {:RESULT = new Primitive.INT(); :};
type            ::= primType:pt                                    {:RESULT = pt; :}
                    | type:t  OPEN_BRACKET CLOSE_BRACKET           {:RESULT = Array(t);:};