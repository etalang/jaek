import java_cup.runtime.*;
import ast.*;
import kotlin.collections.CollectionsKt;
import kotlin.jvm.internal.markers.*;
import java.util.*;

parser code  {:
  public void syntax_error(java_cup.runtime.Symbol current) throws ParseError {
    throw new ParseError(current);
  }
:};
scan with {: return getScanner().next_token(); :};

/* Terminals */
terminal String IDENTIFIER;
terminal String STRING_LITERAL;
terminal Integer CHARACTER_LITERAL;
terminal IntLitInfo INTEGER_LITERAL;
terminal TRUE, FALSE;
terminal INT, BOOL;
terminal BinaryOp.Operation PLUS, MINUS, TIMES, HIGHTIMES, DIVIDE, MODULO, NOT, LT, LEQ, GT, GEQ, AND, OR, EQUALS, EQB, NEQB;

terminal IF, ELSE, WHILE, RETURN, USE, LENGTH,
  OPEN_BRACKET, CLOSE_BRACKET, OPEN_PAREN, CLOSE_PAREN, OPEN_BRACE, CLOSE_BRACE,
  COLON, COMMA, SEMICOLON, UNDERSCORE, UMINUS, LITMINUS;

terminal INTERFACE, PROGRAM;

/* Nonterminals */
nonterminal Eta file;
nonterminal Interface interface;
nonterminal Program program;
nonterminal ArrayList<Use> imports;
nonterminal Use use;
nonterminal ArrayList<Definition> allDefinitions;
nonterminal Definition definition;
nonterminal Method methodHeader;
nonterminal Method method;
nonterminal GlobalDecl globalDecl;
nonterminal ArrayList<Type> typelst;
nonterminal Primitive primType;
nonterminal Type type;
nonterminal Literal primitiveLiteral;
nonterminal Statement.If if;
nonterminal Statement.While while;
nonterminal Statement return;
nonterminal Expr expr;
nonterminal ArrayList<VarDecl.RawVarDecl> methodArgs;
nonterminal Statement.Block returnableBlock;
nonterminal Statement block;
nonterminal ArrayList<Statement> statementList;
nonterminal Statement statement;
nonterminal Statement elseOptional; // might have to add empty list in empty case to type check?
nonterminal Statement.Procedure procedureCall;
nonterminal Expr.FunctionCall functionCall;
nonterminal MultiAssign multiAssign;
nonterminal Statement.ArrayInit arrayInit, arrayNonBlank;
nonterminal VarDecl.InitArr arrayInitStatement;
nonterminal ArrayList<Expr> exprList;
nonterminal AssignTarget assignable;
nonterminal ArrayList<AssignTarget> assignables;
nonterminal VarDecl.RawVarDecl methodArg;
nonterminal VarDecl.RawVarDecl varDecl;
//nonterminal varDeclOrArrayInit;
nonterminal semi;
nonterminal BinaryOp binop;
nonterminal UnaryOp.Operation unop;
nonterminal Expr arrayAccess, indexable;

/* Precedences */
precedence left OR;
precedence left AND;
precedence left EQB, NEQB;
precedence left LT, LEQ, GT, GEQ;
precedence left PLUS, MINUS;
precedence left TIMES, HIGHTIMES, DIVIDE, MODULO;
precedence left UMINUS, NOT;
precedence left LITMINUS;
precedence left COMMA, OPEN_BRACKET, CLOSE_BRACKET, ELSE;
precedence left OPEN_PAREN, CLOSE_PAREN;

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Root */
start with file;
file            ::= INTERFACE interface:It                      {: RESULT = It; :}
                    | PROGRAM program:P                         {: RESULT = P;  :};
interface       ::= interface:it methodHeader:am                {: ArrayList<Method> ml = it.getMethodHeaders(); ml.add(am); RESULT = new Interface(ml); :}
                    |                                           {: RESULT = new Interface(new ArrayList<>());:};
program         ::= imports:Is allDefinitions:Ds                {: RESULT = new Program(Is, Ds); :};

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Imports */
imports         ::= use:u imports:It                            {: It.add(0, u); RESULT = It; :}
                    |                                           {: RESULT = new ArrayList<Use>(); :};
use             ::= USE IDENTIFIER:id semi                      {: RESULT = new Use(id); :};

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Top Level Declarations */
allDefinitions  ::= allDefinitions:Dt definition:d              {: Dt.add(d); RESULT = Dt; :} //could be sketch
                    |                                           {: RESULT = new ArrayList<>(); :};
definition      ::= method:m                                    {: RESULT = m; :}
                    | globalDecl:dc semi                        {: RESULT = dc; :};

/* =============> Global Variables <============= */
// a : int[6] ILLEGAL
// b : int[] = 5
globalDecl      ::= IDENTIFIER:id COLON type:t                                              {: RESULT = new GlobalDecl(id, t, null); :};
globalDecl      ::= IDENTIFIER:id COLON type:t EQUALS primitiveLiteral:pl                   {: RESULT = new GlobalDecl(id, t, pl); :};

/* =============> [Global] Methods <============= */
methodHeader        ::= IDENTIFIER:id OPEN_PAREN methodArgs:Ds CLOSE_PAREN COLON typelst:Ts  {: RESULT = new Method(id, Ds, Ts); :}
                    | IDENTIFIER:id OPEN_PAREN methodArgs:Ds CLOSE_PAREN                     {: RESULT = new Method(id, Ds, new ArrayList<Type>()); :}
                    | IDENTIFIER:id OPEN_PAREN CLOSE_PAREN COLON typelst:Ts                  {: RESULT = new Method(id, new ArrayList<>(), Ts); :}
                    | IDENTIFIER:id OPEN_PAREN CLOSE_PAREN                                   {: RESULT = new Method(id, new ArrayList<>(), new ArrayList<Type>()); :};
methodArg       ::= IDENTIFIER:id COLON type:t                                      {:RESULT = new VarDecl.RawVarDecl(id, t); :};
methodArgs      ::= methodArg:ma                                                    {:RESULT = ParseUtil.singleton(ma); :}
                    | methodArg:ma COMMA methodArgs:mal                             {:mal.add(0, ma); RESULT = mal;:};

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Statements */
statementList   ::= statement:s                                                     {:RESULT = ParseUtil.singleton(s);:}
                    | statementList:sl statement:s                                  {:sl.add(s); RESULT = sl;:};
statement       ::= if:i                                                            {: RESULT = i; :}
                    | while:w                                                       {: RESULT = w; :}
                    | multiAssign:a semi                                            {: RESULT = a; :}
                    | varDecl:d semi                                                {: RESULT = d; :}
                    | arrayInitStatement:a semi                                     {: RESULT = a; :}
                    | procedureCall:fn semi                                         {: RESULT = fn; :};
if              ::= IF expr:e block:b elseOptional:els                              {: RESULT = new Statement.If(e, b, els); :}
                    | IF OPEN_PAREN expr:e CLOSE_PAREN block:b elseOptional:els     {: RESULT = new Statement.If(e, b, els); :};
while           ::= WHILE OPEN_PAREN expr:e CLOSE_PAREN block:b                     {: RESULT = new Statement.While(e, b); :}
                    | WHILE expr:e block:b                                          {: RESULT = new Statement.While(e, b); :};
block           ::= statement:s                                                     {: RESULT = s; :}
                    | returnableBlock:rb                                            {: RESULT = rb; :};
returnableBlock ::= OPEN_BRACE statementList:sLst CLOSE_BRACE                       {: RESULT = new Statement.Block(sLst); :}
                    | OPEN_BRACE statementList:sLst return:r CLOSE_BRACE            {: sLst.add(r); RESULT = new Statement.Block(sLst); :}
                    | OPEN_BRACE CLOSE_BRACE                                        {: RESULT = new Statement.Block(new ArrayList<Statement>()); :}
                    | OPEN_BRACE return:r CLOSE_BRACE                               {: RESULT = new Statement.Block(ParseUtil.singleton(r)); :}
                    | OPEN_BRACE statementList:sLst returnableBlock:rb CLOSE_BRACE  {: sLst.add(rb); RESULT = new Statement.Block(sLst); :}
                    | OPEN_BRACE statementList:sLst
                    returnableBlock:rb return:r CLOSE_BRACE                         {:sLst.add(rb); sLst.add(r); RESULT = new Statement.Block(sLst); :}
                    | OPEN_BRACE
                    returnableBlock:rb statementList:sLst return:r CLOSE_BRACE     {:sLst.add(0, rb); sLst.add(r); RESULT = new Statement.Block(sLst); :}
                    | OPEN_BRACE
                    returnableBlock:rb statementList:sLst CLOSE_BRACE               {:sLst.add(0, rb); RESULT = new Statement.Block(sLst); :}
                    | OPEN_BRACE statementList:sLst1 returnableBlock:rb
                    statementList:sLst2 CLOSE_BRACE                                 {:sLst1.add(rb); sLst1.addAll(sLst2); RESULT = new Statement.Block(sLst1); :}
                    | OPEN_BRACE statementList:sLst1 returnableBlock:rb
                    statementList:sLst2 return:r CLOSE_BRACE                        {:sLst1.add(rb); sLst1.addAll(sLst2); sLst1.add(r); RESULT = new Statement.Block(sLst1); :}
                    | OPEN_BRACE returnableBlock:rb CLOSE_BRACE                     {: RESULT = new Statement.Block(ParseUtil.singleton(rb)); :}
                    | OPEN_BRACE returnableBlock:rb return:r CLOSE_BRACE            {: ArrayList<Statement> st = ParseUtil.singleton(rb); st.add(r); RESULT = new Statement.Block(st); :};
procedureCall   ::= IDENTIFIER:id OPEN_PAREN exprList:vl CLOSE_PAREN                {: RESULT = new Statement.Procedure(id, vl);:} // these should be statements!
                    | IDENTIFIER:id OPEN_PAREN CLOSE_PAREN                          {: RESULT = new Statement.Procedure(id, new ArrayList<Expr>());:};
elseOptional    ::=
                    | ELSE block:b                                                  {: RESULT = b; :};
semi            ::= SEMICOLON | ;
return          ::= RETURN semi                                                     {: RESULT = new Statement.Return(new ArrayList<Expr>()); :}
                    | RETURN exprList:exprLst semi                                  {: RESULT = new Statement.Return(exprLst); :};
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Local Variables */

/* =============> [MULTI] With Assignment <============= */
// includes a = b but also has more ~fun~ stuff with decls like a : int, b = 5, 4
// RESULTS: Declaration + Init (var + []), Assignment (to var and to _)
varDecl         ::= IDENTIFIER:id COLON type:t                     {: RESULT = new VarDecl.RawVarDecl(id, t); :};
assignable      ::= arrayAccess:e1   /*  a[2] = , f(x)[0] = */     {: RESULT = new AssignTarget.ExprAssign(e1); :} //TODO: THOROUGHLY THINK ABOUT THIS ONE
                    | varDecl:vd                                   {: RESULT = new AssignTarget.DeclAssign(vd); :}
                    | UNDERSCORE                                   {: RESULT = new AssignTarget.Underscore(); :}
                    | IDENTIFIER:id                                {: RESULT = new AssignTarget.ExprAssign(new Expr.Identifier(id)); :};
assignables     ::= assignable:at                                  {: RESULT = ParseUtil.singleton(at); :}
                    | assignables:atl COMMA assignable:at          {: atl.add(at); RESULT = atl; :} ; //LEFT RECURSIVE
multiAssign     ::= assignables:tg EQUALS exprList:exprs           {: RESULT = new MultiAssign(tg, exprs);:};

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Initializations */
arrayInitStatement ::= IDENTIFIER:id COLON arrayInit:ar                             {: RESULT = new VarDecl.InitArr(id, ar); :};
arrayInit          ::= arrayNonBlank:anb                                            {: RESULT = anb;:} //TODO: this is a hack really bad structure
                       |  arrayInit:ai OPEN_BRACKET CLOSE_BRACKET                   {: ai.getDimensions().add(0, null); RESULT = ai; :};
arrayNonBlank      ::= primType:pt OPEN_BRACKET expr:e CLOSE_BRACKET                {: RESULT = new Statement.ArrayInit(pt, e); :}
                       | arrayNonBlank:anb OPEN_BRACKET CLOSE_BRACKET               {: anb.getDimensions().add(0, null); RESULT = anb; :}
                       | arrayNonBlank:anb OPEN_BRACKET expr:e CLOSE_BRACKET        {: anb.getDimensions().add(0, e); RESULT = anb; :};
method          ::= methodHeader:am returnableBlock:b                               {: am.setBody(b); RESULT = am; :};
typelst         ::= type:t                                                          {: RESULT = ParseUtil.singleton(t);:}
                    | typelst:tl COMMA type:t                                       {: tl.add(t); RESULT = tl;:}; //LR

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Expressions */
expr            ::= binop:op                                       {: RESULT = op; :}
                    | primitiveLiteral:pl                          {: RESULT = pl; :}
                    | unop:op expr:arg                             {: RESULT = new UnaryOp(op, arg); :} %prec UMINUS
                    | IDENTIFIER:id                                {: RESULT = new Literal.Identifier(id); :} //amazing work
                    | functionCall:fc                              {: RESULT = fc; :}
                    | STRING_LITERAL:s                             {: RESULT = new Literal.StringLit(s); :}
                    | OPEN_BRACE exprList:el CLOSE_BRACE           {: RESULT = new Literal.ArrayLit(el); :}  //array literal
                    | OPEN_BRACE exprList:el COMMA CLOSE_BRACE     {: RESULT = new Literal.ArrayLit(el); :}  //array literal
                    | arrayAccess:aa                               {: RESULT = aa; :}
                    | OPEN_PAREN expr:e CLOSE_PAREN                {: RESULT = e; :}
                    | LENGTH OPEN_PAREN expr:e CLOSE_PAREN         {: RESULT = new Expr.FunctionCall.LengthFn(e); :};
exprList          ::= expr:e                                       {: RESULT = ParseUtil.singleton(e);  :}
                    | exprList:l COMMA expr:e                      {: l.add(e); RESULT = l; :}; //LR
arrayAccess       ::= indexable:e1 OPEN_BRACKET expr:e2 CLOSE_BRACKET {: RESULT = new Expr.ArrayAccess(e1,e2); :};
indexable         ::= functionCall:fc                              {: RESULT = fc; :}
                    | IDENTIFIER:id                                {: RESULT = new Literal.Identifier(id); :}
                    | arrayAccess:aa                               {: RESULT = aa; :};
primitiveLiteral  ::= INTEGER_LITERAL:n                            {: if (n.data.equals("9223372036854775808")) { throw new ParseError(new Token.IntegerToken(n.data, n.line, n.column)); }
                                                                        RESULT = new Literal.IntLit(Long.parseLong(n.data)); :}
                    | MINUS INTEGER_LITERAL:n                      {: RESULT = new Literal.IntLit(Long.parseLong("-" + n.data)); :} %prec LITMINUS
                    | CHARACTER_LITERAL:c                          {: RESULT = new Literal.CharLit(c); :}
                    | FALSE                                        {: RESULT = new Literal.BoolLit(false); :}
                    | TRUE                                         {: RESULT = new Literal.BoolLit(true); :};
functionCall    ::= IDENTIFIER:id OPEN_PAREN exprList:vl CLOSE_PAREN  {: RESULT = new Expr.FunctionCall(id, vl);:} // these should be statements!
                    | IDENTIFIER:id OPEN_PAREN CLOSE_PAREN            {: RESULT = new Expr.FunctionCall(id, new ArrayList<>());:};
unop            ::= MINUS                                          {: RESULT = UnaryOp.Operation.NEG; :}   // cannot differentiate identical token but need diff prec
                    | NOT                                          {: RESULT = UnaryOp.Operation.NOT; :}; // need to take expr
binop           ::= expr:r PLUS expr:l                             {: RESULT = new BinaryOp(BinaryOp.Operation.PLUS,r,l); :}
                    | expr:r TIMES expr:l                                        {: RESULT = new BinaryOp(BinaryOp.Operation.TIMES,r,l); :}
                    | expr:r MINUS expr:l                                        {: RESULT = new BinaryOp(BinaryOp.Operation.MINUS,r,l); :}
                    | expr:r HIGHTIMES expr:l                                    {: RESULT = new BinaryOp(BinaryOp.Operation.HIGHTIMES,r,l); :}
                    | expr:r DIVIDE expr:l                                       {: RESULT = new BinaryOp(BinaryOp.Operation.DIVIDE,r,l); :}
                    | expr:r MODULO expr:l                                       {: RESULT = new BinaryOp(BinaryOp.Operation.MODULO,r,l); :}
                    | expr:r LT expr:l                                           {: RESULT = new BinaryOp(BinaryOp.Operation.LT,r,l); :}
                    | expr:r LEQ expr:l                                          {: RESULT = new BinaryOp(BinaryOp.Operation.LEQ,r,l); :}
                    | expr:r GT expr:l                                           {: RESULT = new BinaryOp(BinaryOp.Operation.GT,r,l); :}
                    | expr:r GEQ expr:l                                          {: RESULT = new BinaryOp(BinaryOp.Operation.GEQ,r,l); :}
                    | expr:r EQB expr:l                                          {: RESULT = new BinaryOp(BinaryOp.Operation.EQB,r,l); :}
                    | expr:r NEQB expr:l                                         {: RESULT = new BinaryOp(BinaryOp.Operation.NEQB,r,l); :}
                    | expr:r AND expr:l                                          {: RESULT = new BinaryOp(BinaryOp.Operation.AND,r,l); :}
                    | expr:r OR expr:l                                           {: RESULT = new BinaryOp(BinaryOp.Operation.OR,r,l); :};

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Types */
primType        ::= BOOL                                           {:RESULT = new Primitive.BOOL(); :}
                    | INT                                          {:RESULT = new Primitive.INT(); :};
type            ::= primType:pt                                    {:RESULT = pt; :}
                    | primType:pt OPEN_BRACKET CLOSE_BRACKET       {:RESULT = new Type.Array(pt);:}
                    | type:t OPEN_BRACKET CLOSE_BRACKET            {:RESULT = new Type.Array(t);:};