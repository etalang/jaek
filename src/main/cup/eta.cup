import java_cup.runtime.*;
import ast.*;
import kotlin.collections.CollectionsKt;
import kotlin.jvm.internal.markers.*;
import java.util.*;

parser code  {:
  public void syntax_error(java_cup.runtime.Symbol current) {
    throw new ParseError(current);
  }
:};
scan with {: return getScanner().next_token(); :};

/* Terminals */
terminal String IDENTIFIER;
terminal String STRING_LITERAL;
terminal Integer CHARACTER_LITERAL;
terminal String INTEGER_LITERAL;
terminal TRUE, FALSE;
terminal INT, BOOL;
terminal BinaryOp.Operation PLUS, MINUS, TIMES, HIGHTIMES, DIVIDE, MODULO, NOT, LT, LEQ, GT, GEQ, AND, OR, EQUALS, EQB, NEQB;

terminal IF, ELSE, WHILE, RETURN, USE, LENGTH,
  OPEN_BRACKET, CLOSE_BRACKET, OPEN_PAREN, CLOSE_PAREN, OPEN_BRACE, CLOSE_BRACE,
  COLON, COMMA, SEMICOLON, UNDERSCORE, UMINUS;

terminal INTERFACE, PROGRAM;

/* Nonterminals */
nonterminal Eta file;
nonterminal Interface interface;
nonterminal Program program;
nonterminal ArrayList<Use> imports;
nonterminal Use use;
nonterminal ArrayList<Definition> allDefinitions;
nonterminal Definition definition;
nonterminal Method methodHeader;
nonterminal Method method;
nonterminal GlobalDecl globalDecl;
nonterminal ArrayList<Type> typelst;
nonterminal Primitive primType;
nonterminal Type type;
nonterminal Literal primitiveLiteral;
nonterminal Statement.If if;
nonterminal Statement.While while;
nonterminal Statement return;
nonterminal Expr expr;
nonterminal ArrayList<VarDecl.RawVarDecl> methodArgs;
nonterminal Statement.Block returnableBlock, block;
nonterminal ArrayList<Statement> statementList;
nonterminal Statement statement;
nonterminal Statement.Block elseOptional; // might have to add empty list in empty case to type check?
nonterminal Statement.Procedure procedureCall;
nonterminal Expr.FunctionCall functionCall;
nonterminal MultiAssign multiAssign;
nonterminal ArrayInit arrayInit, arrayNonBlank;
nonterminal VarDecl.InitArr arrayInitStatement;
nonterminal ArrayList<Expr> exprList;
nonterminal AssignTarget assignable;
nonterminal ArrayList<AssignTarget> assignables;
nonterminal VarDecl.RawVarDecl methodArg;
nonterminal VarDecl.RawVarDecl varDecl;
//nonterminal varDeclOrArrayInit;
nonterminal semi;
nonterminal BinaryOp.Operation binop;
nonterminal UnaryOp.Operation unop;
nonterminal Expr arrayAccess, indexable;
nonterminal ArrayList<Expr> nonemptyBrackets;
nonterminal Integer emptyBrackets;

/* Precedences */
precedence left OR;
precedence left AND;
precedence left EQB, NEQB;
precedence left LT, LEQ, GT, GEQ;
precedence left PLUS, MINUS;
precedence left TIMES, HIGHTIMES, DIVIDE, MODULO;
precedence left UMINUS, NOT;
precedence left COMMA, OPEN_BRACKET, CLOSE_BRACKET, ELSE;
precedence left OPEN_PAREN, CLOSE_PAREN;

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Root */
start with file;
file            ::= INTERFACE interface:It                      {: RESULT = It; :}
                    | PROGRAM program:P                         {: RESULT = P;  :};
interface       ::= interface:it methodHeader:am                {: ArrayList<Method> ml = it.getMethodHeaders(); ml.add(am); RESULT = new Interface(ml); :}
                    |                                           {: RESULT = new Interface(new ArrayList<>());:};
program         ::= imports:Is allDefinitions:Ds                {: RESULT = new Program(Is, Ds); :};

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Imports */
imports         ::= use:u imports:It                            {: It.add(0, u); RESULT = It; :}
                    |                                           {: RESULT = new ArrayList<Use>(); :};
use             ::= USE IDENTIFIER:id semi                      {: RESULT = new Use(id); :};

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Top Level Declarations */
allDefinitions  ::= allDefinitions:Dt definition:d              {: Dt.add(d); RESULT = Dt; :} //could be sketch
                    |                                           {: RESULT = new ArrayList<>(); :};
definition      ::= method:m                                    {: RESULT = m; :}
                    | globalDecl:dc semi                        {: RESULT = dc; :};

/* =============> Global Variables <============= */
// a : int[6] ILLEGAL
// b : int[] = 5

//
//globalMultiDeclaration ::= globalDecls:gD                      {: RESULT = new GlobalDeclarationBuilder(gD, null); :}
//                        | globalDecls:gD EQUALS primLitLst:pl  {: RESULT = new GlobalDeclarationBuilder(gD, pl); :};
//globalDecls     ::=  globalDecl:d                              {: RESULT = ParseUtil.singleton(d); :}
//                    | globalDecl:d COMMA globalDecls:Ds        {: Ds.add(0, d); RESULT = Ds; :};
globalDecl      ::= IDENTIFIER:id COLON type:t                                              {: RESULT = new GlobalDecl(id, t, null); :};
globalDecl      ::= IDENTIFIER:id COLON type:t EQUALS primitiveLiteral:pl                   {: RESULT = new GlobalDecl(id, t, pl); :};

/* =============> [Global] Methods <============= */
methodHeader        ::= IDENTIFIER:id OPEN_PAREN methodArgs:Ds CLOSE_PAREN COLON typelst:Ts  {: RESULT = new Method(id, Ds, Ts); :}
                    | IDENTIFIER:id OPEN_PAREN methodArgs:Ds CLOSE_PAREN                     {: RESULT = new Method(id, Ds, new ArrayList<Type>()); :}
                    | IDENTIFIER:id OPEN_PAREN CLOSE_PAREN COLON typelst:Ts                  {: RESULT = new Method(id, new ArrayList<>(), Ts); :}
                    | IDENTIFIER:id OPEN_PAREN CLOSE_PAREN                                   {: RESULT = new Method(id, new ArrayList<>(), new ArrayList<Type>()); :};
methodArg       ::= IDENTIFIER:id COLON type:t                                      {:RESULT = new VarDecl.RawVarDecl(id, t); :};
methodArgs      ::= methodArg:ma                                                    {:RESULT = ParseUtil.singleton(ma); :}
                    | methodArg:ma COMMA methodArgs:mal                             {:mal.add(0, ma); RESULT = mal;:};

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Statements */
statementList   ::= statement:s                                                     {:RESULT = ParseUtil.singleton(s);:}
                    | statement:s statementList:sl                                  {:sl.add(0, s); RESULT = sl;:};
statement       ::= if:i                                                            {: RESULT = i; :}
                    | while:w                                                       {: RESULT = w; :}
                    | multiAssign:a semi                                            {: RESULT = a; :}
                    | IDENTIFIER:id COLON primType:pt nonemptyBrackets:nl emptyBrackets:el
                    {: if (nl.size() == 0) {
                            Type t = pt;
                            for (int i = 0; i < el; i++) { t = new Type.Array(t); }
                            RESULT = new VarDecl.RawVarDecl(id, t);
                        } else {
                            ArrayInit ai = new ArrayInit.ArrPtr(pt, nl.get(0));
                            for (int i = 1; i < nl.size(); i++) {
                                ai = new ArrayInit.Dim(ai, nl.get(i));
                            }
                            RESULT = new VarDecl.InitArr(id, ai);
                        } :}
                        // put some complex code here to parse out the difference
//                    | varDecl:d semi                                                {: RESULT = d; :}
                    //| arrayInitStatement:a semi                                     {: RESULT = a; :}
                    | procedureCall:fn semi                                         {: RESULT = fn; :};
nonemptyBrackets ::=  {:RESULT = new ArrayList<Expr>(); :} //empty production returns empty list
                    | OPEN_BRACKET expr:e CLOSE_BRACKET nonemptyBrackets:nl  {: nl.add(0, e); RESULT = nl;:};// cons expr to front of nl
emptyBrackets   ::= {:RESULT = 0;:}// empty production returns 0
                    | OPEN_BRACKET CLOSE_BRACKET emptyBrackets:n                 {:RESULT = 1 + n;:}; // returns 1 + n
if              ::= IF expr:e block:b elseOptional:els                              {: RESULT = new Statement.If(e, b, els); :}
                    | IF OPEN_PAREN expr:e CLOSE_PAREN block:b elseOptional:els     {: RESULT = new Statement.If(e, b, els); :};
while           ::= WHILE OPEN_PAREN expr:e CLOSE_PAREN block:b                     {: RESULT = new Statement.While(e, b); :}
                    | WHILE expr:e block:b                                          {: RESULT = new Statement.While(e, b); :};
block           ::= statement:s                                                     {: RESULT = new Statement.Block(ParseUtil.singleton(s)); :}
                    | returnableBlock:rb                                            {: RESULT = rb; :};
returnableBlock ::= OPEN_BRACE statementList:sLst CLOSE_BRACE                       {: RESULT = new Statement.Block(sLst); :}
                    | OPEN_BRACE statementList:sLst return:r CLOSE_BRACE            {: sLst.add(r); RESULT = new Statement.Block(sLst); :} // is this being added to the end??
                    | OPEN_BRACE return:r CLOSE_BRACE                               {: RESULT = new Statement.Block(ParseUtil.singleton(r)); :};
procedureCall   ::= IDENTIFIER:id OPEN_PAREN exprList:vl CLOSE_PAREN                {: RESULT = new Statement.Procedure(id, vl);:} // these should be statements!
                    | IDENTIFIER:id OPEN_PAREN CLOSE_PAREN                          {: RESULT = new Statement.Procedure(id, new ArrayList<Expr>());:};
elseOptional         ::=
                    | ELSE block:b                                             {: RESULT = new Statement.Block(ParseUtil.singleton(b)); :};
semi            ::= SEMICOLON | ;
return          ::= RETURN semi                                                     {: RESULT = new Statement.Return(new ArrayList<Expr>()); :}
                    | RETURN exprList:exprLst semi                                  {: RESULT = new Statement.Return(exprLst); :};
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Local Variables */

/* =============> [MULTI] No Assignment <============= */
//DOESN'T EXIST ANYMORE
// RESULTS: Declaration No Init OR Array Init
//multiDeclOrArrayInit ::= varDecl:vd     {:RESULT = ParseUtil.singleton(new Statement.DeclareInit.Declare(vd));:}
//                        | arrayinit:ai  {:RESULT = ParseUtil.singleton(new Statement.DeclareInit.Init(ai));:}
//                        | varDecl:vd COMMA multiDeclOrArrayInit:mdai {:Statement.DeclareInit di = new Statement.DeclareInit.Declare(vd); mdai.add(0, di); RESULT = mdai; :}
//                        | arrayinit:ai COMMA multiDeclOrArrayInit:mdai {:Statement.DeclareInit di = new Statement.DeclareInit.Init(ai); mdai.add(0, di); RESULT = mdai;:} ;
//varDeclOrArrayInit ::= varDecl | arrayinit;

/* =============> [MULTI] With Assignment <============= */
// includes a = b but also has more ~fun~ stuff with decls like a : int, b = 5, 4
// RESULTS: Declaration + Init (var + []), Assignment (to var and to _)
varDecl         ::= IDENTIFIER:id COLON type:t                     {: RESULT = new VarDecl.RawVarDecl(id, t); :};
assignable      ::= arrayAccess:e1   /*  a[2] = , f(x)[0] = */ {: RESULT = new AssignTarget.ExprAssign(e1); :} //TODO: THOROUGHLY THINK ABOUT THIS ONE
                    | varDecl:vd                                   {: RESULT = new AssignTarget.DeclAssign(vd); :}
                    | UNDERSCORE                                   {: RESULT = new AssignTarget.Underscore(); :}
                    | IDENTIFIER:id                                {: RESULT = new AssignTarget.ExprAssign(new Expr.Identifier(id)); :};
assignables     ::= assignable:at                                  {: RESULT = ParseUtil.singleton(at); :}
                    | assignables:atl COMMA assignable:at          {: atl.add(at); RESULT = atl; :} ; //LEFT RECURSIVE
multiAssign     ::= assignables:tg EQUALS exprList:exprs           {: RESULT = new MultiAssign(tg, exprs);:};

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Initializations */
arrayInitStatement ::= IDENTIFIER:id COLON arrayInit:ar                              {: RESULT = new VarDecl.InitArr(id, ar); :};
arrayInit          ::= arrayNonBlank:anb                                               {: RESULT = anb;:}
                     |  arrayInit:ai OPEN_BRACKET CLOSE_BRACKET                         {: RESULT = new ArrayInit.Dim(ai, null); :};
arrayNonBlank       ::= primType:pt OPEN_BRACKET expr:e CLOSE_BRACKET                   {: RESULT = new ArrayInit.ArrPtr(pt, e); :}
                       | arrayNonBlank:anb OPEN_BRACKET expr:e CLOSE_BRACKET            {: RESULT = new ArrayInit.Dim(anb, e); :};

method          ::= methodHeader:am returnableBlock:b                               {: am.setBody(b); RESULT = am; :};
typelst         ::= type:t                                                          {: RESULT = ParseUtil.singleton(t);:}
                    | typelst:tl COMMA type:t                                       {: tl.add(t); RESULT = tl;:}; //LR

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Expressions */
expr            ::= expr:l binop:op expr:r                         {: RESULT = new BinaryOp(op, l, r); :}
                    | unop:op expr:arg                             {: RESULT = new UnaryOp(op, arg); :}
                    | IDENTIFIER:id                                {: RESULT = new Literal.Identifier(id); :} //amazing work
                    | functionCall:fc                              {: RESULT = fc; :}
                    | STRING_LITERAL:s                             {: RESULT = new Literal.StringLit(s); :}
                    | primitiveLiteral:pl                          {: RESULT = pl; :}
                    | OPEN_BRACE exprList:el CLOSE_BRACE           {: RESULT = new Literal.ArrayLit(el); :}  //array literal
                    | arrayAccess:aa                               {: RESULT = aa; :}
                    | OPEN_PAREN expr:e CLOSE_PAREN                {: RESULT = e; :}
                    | LENGTH OPEN_PAREN expr:e CLOSE_PAREN         {: RESULT = new Expr.FunctionCall.LengthFn(e); :};
exprList          ::= expr:e                                       {: RESULT = ParseUtil.singleton(e);  :}
                    | exprList:l COMMA expr:e                      {: l.add(e); RESULT = l; :}; //LR
arrayAccess       ::= indexable:e1 OPEN_BRACKET expr:e2 CLOSE_BRACKET   {: RESULT = new Expr.ArrayAccess(e1,e2); :};
indexable         ::= functionCall:fc                              {: RESULT = fc; :}
                    | IDENTIFIER:id                                {: RESULT = new Literal.Identifier(id); :}
                    | arrayAccess:aa                               {: RESULT = aa; :};
primitiveLiteral  ::= INTEGER_LITERAL:n                            {: RESULT = new Literal.IntLit(Long.parseLong(n)); :}
                    | CHARACTER_LITERAL:c                          {: RESULT = new Literal.CharLit(c); :}
                    | FALSE                                        {: RESULT = new Literal.BoolLit(false); :}
                    | TRUE                                         {: RESULT = new Literal.BoolLit(true); :};
functionCall    ::= IDENTIFIER:id OPEN_PAREN exprList:vl CLOSE_PAREN  {: RESULT = new Expr.FunctionCall(id, vl);:} // these should be statements!
                    | IDENTIFIER:id OPEN_PAREN CLOSE_PAREN            {: RESULT = new Expr.FunctionCall(id, new ArrayList<>());:};
unop            ::= MINUS %prec UMINUS |                           {: RESULT = UnaryOp.Operation.NEG; :}// cannot differentiate identical token but need diff prec
                    NOT                                            {: RESULT = UnaryOp.Operation.NOT; :}; // need to take expr
binop           ::= PLUS                                           {: RESULT = BinaryOp.Operation.PLUS; :}
                    | MINUS                                        {: RESULT = BinaryOp.Operation.MINUS; :}
                    | TIMES                                        {: RESULT = BinaryOp.Operation.TIMES; :}
                    | HIGHTIMES                                    {: RESULT = BinaryOp.Operation.HIGHTIMES; :}
                    | DIVIDE                                       {: RESULT = BinaryOp.Operation.DIVIDE; :}
                    | MODULO                                       {: RESULT = BinaryOp.Operation.MODULO; :}
                    | LT                                           {: RESULT = BinaryOp.Operation.LT; :}
                    | LEQ                                          {: RESULT = BinaryOp.Operation.LEQ; :}
                    | GT                                           {: RESULT = BinaryOp.Operation.GT; :}
                    | GEQ                                          {: RESULT = BinaryOp.Operation.GEQ; :}
                    | EQB                                          {: RESULT = BinaryOp.Operation.EQB; :}
                    | NEQB                                         {: RESULT = BinaryOp.Operation.NEQB; :}
                    | AND                                          {: RESULT = BinaryOp.Operation.AND; :}
                    | OR                                           {: RESULT = BinaryOp.Operation.OR; :};

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Types  -> previous code  | primType:t       {:RESULT = new Type.Array(t);:}; */
primType        ::= BOOL                                           {:RESULT = new Primitive.BOOL(); :}
                    | INT                                          {:RESULT = new Primitive.INT(); :};
type            ::= primType:pt emptyBrackets:n
                    {:Type t = pt;  for (int i = 0; i < n; i++) { t = new Type.Array(t); } RESULT = t; :};