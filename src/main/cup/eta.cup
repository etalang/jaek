import ast.*;
import java.util.*;
import errors.*;
import java.io.File;

parser code  {:
  public void syntax_error(java_cup.runtime.Symbol cur_token) {}
  public void unrecovered_syntax_error(java_cup.runtime.Symbol current) throws ParseError {
    throw new ParseError(current,file);
  }
  private File file;
  private String extension;
  public void setFile(File file) {this.file = file;}
  public void setExtension(String extension) {this.extension = extension;}
:};
scan with {: return getScanner().next_token(); :};

/* Terminals */
terminal String IDENTIFIER;
terminal String STRING_LITERAL;
terminal Integer CHARACTER_LITERAL;
terminal String INTEGER_LITERAL;
terminal TRUE, FALSE;
terminal INT, BOOL;
terminal String NULL;
terminal String PLUS, MINUS, TIMES, HIGHTIMES, DIVIDE, MODULO, NOT, LT, LEQ, GT, GEQ, AND, OR, EQUALS, EQB, NEQB;

terminal String RECORD;
terminal String IF, ELSE, WHILE, RETURN, BREAK, USE, LENGTH,
  OPEN_BRACKET, CLOSE_BRACKET, OPEN_PAREN, CLOSE_PAREN, OPEN_BRACE, CLOSE_BRACE,
  COLON, COMMA, SEMICOLON, PERIOD, UNDERSCORE, UMINUS;

terminal PROGRAM, INTERFACE;

/* Nonterminals */
nonterminal Eta file;
nonterminal Interface interface;
nonterminal Program program;
nonterminal ArrayList<Use> imports;
nonterminal Use use;
nonterminal ArrayList<Definition> globalDefinitions, allDefinitions;
nonterminal Definition definition;
nonterminal Method methodHeader;
nonterminal Method method;
nonterminal GlobalDecl globalDecl;
nonterminal ArrayList<Type> typelst;
nonterminal Primitive primType;
nonterminal Type type;
nonterminal Literal primitiveLiteral;
nonterminal Statement.If if;
nonterminal Statement.While while;
nonterminal Statement return;
nonterminal Expr expr;
nonterminal ArrayList<VarDecl.RawVarDeclList> methodArgs;
nonterminal Statement.Block returnableBlock;
nonterminal Statement block;
nonterminal ArrayList<Statement> statementOrBlockList;
nonterminal Statement statement;
nonterminal Statement elseOptional; // might have to add empty list in empty case to type check?
nonterminal Statement.Procedure procedureCall;
nonterminal Expr.FunctionCall functionCall;
nonterminal MultiAssign multiAssign;
nonterminal Statement.ArrayInit arrayInit;
nonterminal VarDecl.InitArr arrayInitStatement;
nonterminal ArrayList<Expr> exprList;
nonterminal ArrayList<AssignTarget> assignable;
nonterminal ArrayList<AssignTarget> assignables;
nonterminal VarDecl.RawVarDeclList methodArg;
nonterminal VarDecl.RawVarDeclList varDecl;
nonterminal semi;
nonterminal BinaryOp binop;
nonterminal ParseUtil.UnOpBundle unop;
nonterminal Expr.ArrayAccess arrayAccess;
nonterminal Expr indexable, arrayLiteral;
nonterminal Expr.Field field;
nonterminal RhoRecord record;
nonterminal Definition header;
nonterminal ArrayList<Definition> headers;
nonterminal RhoRecord recordHeader;
nonterminal Type.RecordType recordType;
nonterminal VarDecl.RawVarDeclList multiVarDecl;
nonterminal ArrayList<VarDecl.RawVarDeclList> multiVarDeclList;

/* Precedences */
precedence left OR;
precedence left AND;
precedence left EQB, NEQB;
precedence left LT, LEQ, GT, GEQ;
precedence left PLUS, MINUS;
precedence left TIMES, HIGHTIMES, DIVIDE, MODULO;
precedence left UMINUS, NOT;
precedence left COMMA, OPEN_BRACKET, CLOSE_BRACKET, ELSE;
precedence left OPEN_PAREN, CLOSE_PAREN;

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Root */
start with file;
file            ::= INTERFACE interface:It                      {: RESULT = It; :}
                    | PROGRAM program:P                         {: RESULT = P;  :};
interface       ::= imports:Is headers:Hds                      {: if (Is.size() > 0) RESULT = new Interface.EtaInterface(Hds);
                                                                   else RESULT = new Interface.RhoInterface(Is, Hds); :};
program         ::= imports:Is allDefinitions:Ds                {: if (extension.equals("eta")) RESULT = new Program.EtaProgram(Is, Ds);
                                                                   else RESULT = new Program.RhoModule(Is, Ds); :};

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Imports */
imports         ::= use:u imports:It                            {: It.add(0, u); RESULT = It; :}
                    |                                           {: RESULT = new ArrayList<Use>(); :};
use             ::= USE:u IDENTIFIER:id semi                    {: if (extension.equals("eti"))
                                                                   { throw new ParseError(new Token.StringToken(u, uleft, uright), file); }
                                                                   RESULT = new Use(id, new Terminal(idleft,idright)); :};

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Top Level Declarations */
allDefinitions  ::= allDefinitions:Dt definition:d              {: Dt.add(d); RESULT = Dt; :}
                    | globalDefinitions:Dt method:m             {: Dt.add(m); RESULT = Dt; :}
                    | method:m                                  {: RESULT = ParseUtil.singleton(m); :}
                    | record:r                                  {: RESULT = ParseUtil.singleton(r); :};
globalDefinitions  ::= globalDefinitions:Dt globalDecl:dc semi  {: Dt.add(dc); RESULT = Dt; :} //could be sketch
                    | globalDecl:dc semi                        {: RESULT = ParseUtil.singleton(dc); :};
definition      ::= method:m                                    {: RESULT = m; :}
                    | globalDecl:dc semi                        {: RESULT = dc; :}
                    | record:r                                  {: RESULT = r; :};

/* =============> Global Variables <============= */
// a : int[6] ILLEGAL
// b : int[] = 5
globalDecl      ::= IDENTIFIER:id COLON type:t EQUALS primitiveLiteral:pl                    {: RESULT = new GlobalDecl(ParseUtil.singleton(id), t, pl, new Terminal(idleft,idright)); :}
                    | IDENTIFIER:id COLON type:t EQUALS MINUS INTEGER_LITERAL:n              {: if (n.equals("-9223372036854775808")) { throw new ParseError(new Token.StringToken(n, nleft, nright),file); }
                                                                                                RESULT = new GlobalDecl(ParseUtil.singleton(id), t, new Literal.IntLit(Long.parseLong(n), new Terminal(idleft,idright)), new Terminal(idleft,idright)); :}
                    | multiVarDecl:mvd                                                       {: RESULT = new GlobalDecl(mvd.getIds(), mvd.getType(), null, new Terminal(mvdleft,mvdright)); :};

/* =============> [Global] Methods <============= */
header              ::= methodHeader:am                                                      {: RESULT = am; :}
                    | recordHeader:ar                                                        {: RESULT = ar; :};
headers             ::=  headers:hds header:hd                                               {: hds.add(hd); RESULT = hds; :}
                    | header:hd                                                              {: RESULT = ParseUtil.singleton(hd); :};
methodHeader        ::= IDENTIFIER:id OPEN_PAREN methodArgs:Ds CLOSE_PAREN COLON typelst:Ts  {: RESULT = new Method(id, Ds, Ts, new Terminal(idleft,idright)); :}
                    | IDENTIFIER:id OPEN_PAREN methodArgs:Ds CLOSE_PAREN                     {: RESULT = new Method(id, Ds, new ArrayList<Type>(), new Terminal(idleft,idright)); :}
                    | IDENTIFIER:id OPEN_PAREN CLOSE_PAREN COLON typelst:Ts                  {: RESULT = new Method(id, new ArrayList<>(), Ts, new Terminal(idleft,idright)); :}
                    | IDENTIFIER:id OPEN_PAREN CLOSE_PAREN                                   {: RESULT = new Method(id, new ArrayList<>(), new ArrayList<Type>(), new Terminal(idleft,idright)); :};
recordHeader        ::= RECORD:r IDENTIFIER:id OPEN_BRACE CLOSE_BRACE                        {: if (extension.equals("eta") || extension.equals("eti")) { throw new ParseError(new Token.StringToken(r, rleft, rright), file); }
                                                                                                RESULT = new RhoRecord(id, new ArrayList<>(), new Terminal(idleft, idright)); :};
methodArg           ::= IDENTIFIER:id COLON type:t                                           {: Terminal terminal = new Terminal(idleft,idright);
                                                                                                RESULT = new VarDecl.RawVarDeclList(ParseUtil.singleton(id), t, ParseUtil.singleton(terminal), terminal); :};
methodArgs          ::= methodArg:ma                                                         {: RESULT = ParseUtil.singleton(ma); :}
                    | methodArg:ma COMMA methodArgs:mal                                      {: mal.add(0, ma); RESULT = mal; :};

/* =============> [Global] Records <============= */
record              ::= RECORD:r IDENTIFIER:id OPEN_BRACE multiVarDeclList:vdl CLOSE_BRACE   {: if (extension.equals("eta") || extension.equals("eti")) { throw new ParseError(new Token.StringToken(r, rleft, rright), file) ;}
                                                                                                RESULT = new RhoRecord(id, vdl, new Terminal(idleft, idright)); :}
                        | recordHeader:rh                                                    {: RESULT = rh; :};
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Statements */
statementOrBlockList   ::= statement:s                                              {:RESULT = ParseUtil.singleton(s); :}
                           | returnableBlock:rb                                     {:RESULT = ParseUtil.singleton(rb); :}
                           | statementOrBlockList:sbl statement:s                   {:sbl.add(s); RESULT = sbl; :}
                           | statementOrBlockList:sbl returnableBlock:rb            {:sbl.add(rb); RESULT = sbl; :};
statement       ::= if:i                                                            {: RESULT = i; :}
                    | while:w                                                       {: RESULT = w; :}
                    | multiAssign:a semi                                            {: RESULT = a; :}
                    | arrayInitStatement:a semi                                     {: RESULT = a; :}
                    | procedureCall:fn semi                                         {: RESULT = fn; :}
                    | BREAK:b semi                                                  {: if (extension.equals("eta") || extension.equals("eti")) { throw new ParseError(new Token.StringToken(b, bleft, bright),file); }
                                                                                       RESULT = new Statement.Break(new Terminal(bleft,bright)); :}
                    | multiVarDecl:mvd semi                                         {: RESULT = mvd; :};
if              ::= IF:o expr:e block:b elseOptional:els                            {: RESULT = new Statement.If(e, b, els, new Terminal(oleft,oright)); :}
                    | IF:o OPEN_PAREN expr:e CLOSE_PAREN block:b elseOptional:els   {: RESULT = new Statement.If(e, b, els, new Terminal(oleft,oright)); :};
while           ::= WHILE:o OPEN_PAREN expr:e CLOSE_PAREN block:b                   {: RESULT = new Statement.While(e, b, new Terminal(oleft,oright)); :}
                    | WHILE:o expr:e block:b                                        {: RESULT = new Statement.While(e, b, new Terminal(oleft,oright)); :};
block           ::= statement:s                                                     {: RESULT = s; :}
                    | returnableBlock:rb                                            {: RESULT = rb; :};
returnableBlock ::= OPEN_BRACE:b statementOrBlockList:sbl CLOSE_BRACE               {: RESULT = new Statement.Block(sbl, new Terminal(bleft, bright)); :}
                    | OPEN_BRACE:b statementOrBlockList:sbl return:r CLOSE_BRACE    {: sbl.add(r); RESULT = new Statement.Block(sbl, new Terminal(bleft, bright)); :}
                    | OPEN_BRACE:b return:r CLOSE_BRACE                             {: RESULT = new Statement.Block(ParseUtil.singleton(r), new Terminal(bleft, bright)); :}
                    | OPEN_BRACE:b CLOSE_BRACE                                      {: RESULT = new Statement.Block(new ArrayList<Statement>(), new Terminal(bleft, bright)); :};
procedureCall   ::= IDENTIFIER:id OPEN_PAREN exprList:vl CLOSE_PAREN                {: RESULT = new Statement.Procedure(id, vl, new Terminal(idleft,idright)); :} // these should be statements!
                    | IDENTIFIER:id OPEN_PAREN CLOSE_PAREN                          {: RESULT = new Statement.Procedure(id, new ArrayList<Expr>(), new Terminal(idleft,idright)); :};
elseOptional    ::=
                    | ELSE block:b                                                  {: RESULT = b; :};
semi            ::= SEMICOLON | ;
return          ::= RETURN:r semi                                                   {: RESULT = new Statement.Return(new ArrayList<Expr>(), new Terminal(rleft,rright)); :}
                    | RETURN:r exprList:exprLst semi                                {: RESULT = new Statement.Return(exprLst, new Terminal(rleft,rright)); :};
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Local Variables */

/* =============> [MULTI] With Assignment <============= */
// includes a = b but also has more ~fun~ stuff with decls like a : int, b = 5, 4
// RESULTS: Declaration + Init (var + []), Assignment (to var and to _)
varDecl         ::= IDENTIFIER:id COLON type:t                     {: Terminal terminal = new Terminal(idleft,idright);
                                                                      VarDecl.RawVarDeclList decl = new VarDecl.RawVarDeclList(ParseUtil.singleton(id), t, ParseUtil.singleton(terminal), terminal);
                                                                      decl.getIdLocations().add(terminal);
                                                                      RESULT = decl; :};
multiVarDecl    ::= IDENTIFIER:id COMMA:c multiVarDecl:mvd         {: //if (extension.equals("eta") || extension.equals("eti")) { throw new ParseError(new Token.StringToken(c, cleft, cright),file); }
                                                                      if (extension.equals("ri")) { throw new ParseError(new Token.StringToken(id, idleft, idright),file); }
                                                                      Terminal terminal = new Terminal(idleft,idright);
                                                                      mvd.getIds().add(0,id);
                                                                      mvd.getIdLocations().add(0,terminal);
                                                                      RESULT = mvd; :}
                    | varDecl:vd                                   {: RESULT = vd; :};
multiVarDeclList::= multiVarDecl:mvd semi                          {: RESULT = ParseUtil.singleton(mvd); :}
                    | multiVarDecl:mvd semi multiVarDeclList:mvl   {: mvl.add(mvd); RESULT = mvl; :};
assignable      ::= arrayAccess:e1   /*  a[2] = , f(x)[0] = */     {: RESULT = ParseUtil.singleton(new AssignTarget.ArrayAssign(e1)); :}
                    | multiVarDecl:mvd                             {: ArrayList<String> ids = mvd.getIds();
                                                                      ArrayList<AssignTarget> assignables = new ArrayList<AssignTarget>();
                                                                      Terminal terminal;
                                                                      for (int i = 0; i < ids.size() - 1; i ++)
                                                                      { terminal = mvd.getIdLocations().get(i);
                                                                      assignables.add(new AssignTarget.IdAssign(new Expr.Identifier(ids.get(i), terminal))); }
                                                                      terminal = mvd.getIdLocations().get(ids.size() - 1);
                                                                      assignables.add(new AssignTarget.DeclAssign(new VarDecl.RawVarDeclList(ParseUtil.singleton(ids.get(ids.size() - 1)), mvd.getType(), ParseUtil.singleton(terminal), terminal)));
                                                                      RESULT = assignables; :}
                    | UNDERSCORE:u                                 {: RESULT = ParseUtil.singleton(new AssignTarget.Underscore(new Terminal(uleft,uright))); :}
                    | IDENTIFIER:id                                {: RESULT = ParseUtil.singleton(new AssignTarget.IdAssign(new Expr.Identifier(id, new Terminal(idleft,idright)))); :}
                    | field:f                                      {: RESULT = ParseUtil.singleton(new AssignTarget.FieldAssign(f)); :};
assignables     ::= assignable:at                                  {: RESULT = at; :}
                    | assignables:atl COMMA assignable:at          {: atl.addAll(at); RESULT = atl; :} ; //LEFT RECURSIVE
multiAssign     ::= assignables:tg EQUALS:o exprList:exprs         {: RESULT = new MultiAssign(tg, exprs, new Terminal(oleft,oright)); :};

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Initializations */
arrayInitStatement ::= IDENTIFIER:id COLON arrayInit:ar                         {: RESULT = new VarDecl.InitArr(id, ar, new Terminal(idleft,idright)); :};
arrayInit      ::= primType:pt OPEN_BRACKET expr:e CLOSE_BRACKET                {: RESULT = new Statement.ArrayInit(pt, e); :}
                   | arrayInit:anb OPEN_BRACKET CLOSE_BRACKET                   {: anb.getDimensions().add(0, null); RESULT = anb; :}
                   | arrayInit:anb OPEN_BRACKET expr:e CLOSE_BRACKET            {: anb.getDimensions().add(0, e); RESULT = anb; :};
method          ::= methodHeader:am returnableBlock:b                           {: am.setBody(b); RESULT = am; :};
typelst         ::= type:t                                                      {: RESULT = ParseUtil.singleton(t); :}
                    | typelst:tl COMMA type:t                                   {: tl.add(t); RESULT = tl; :}; //LR

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Expressions */
expr            ::= binop:op                                         {: RESULT = op; :}
                    | primitiveLiteral:pl                            {: RESULT = pl; :}
                    | unop:op expr:arg                               {: RESULT = new UnaryOp(op.operation, arg, op.terminal); :} %prec UMINUS //TODO: inline please
                    | indexable:in                                   {: RESULT = in; :}
                    | arrayLiteral:al                                {: RESULT = al; :}
                    | STRING_LITERAL:s                               {: RESULT = new Literal.StringLit(s,new Terminal(sleft,sright)); :}
                    | expr:e1 OPEN_BRACKET:b expr:e2 CLOSE_BRACKET   {: RESULT = new Expr.ArrayAccess(e1, e2, new Terminal(bleft,bright)); :}
                    | OPEN_PAREN expr:e CLOSE_PAREN                  {: RESULT = e; :}
                    | LENGTH:l OPEN_PAREN expr:e CLOSE_PAREN         {: RESULT = new Expr.FunctionCall.LengthFn(e, new Terminal(lleft,lright)); :}
                    | expr:e PERIOD IDENTIFIER:id                    {: RESULT = new Expr.Field(e, id, new Terminal(eleft,eright)); :};
exprList          ::= expr:e                                         {: RESULT = ParseUtil.singleton(e);  :}
                    | exprList:l COMMA expr:e                        {: l.add(e); RESULT = l; :}; //LR
arrayAccess       ::= indexable:e1 OPEN_BRACKET:b expr:e2 CLOSE_BRACKET {: RESULT = new Expr.ArrayAccess(e1,e2,new Terminal(bleft,bright)); :};
indexable         ::= functionCall:fc                                {: RESULT = fc; :}
                    | IDENTIFIER:id                                  {: RESULT = new Literal.Identifier(id,new Terminal(idleft,idright)); :}
                    | arrayAccess:aa                                 {: RESULT = aa; :};
arrayLiteral     ::= OPEN_BRACE:b exprList:el CLOSE_BRACE            {: RESULT = new Literal.ArrayLit(el, new Terminal(bleft,bright)); :}
                    | OPEN_BRACE:b exprList:el COMMA CLOSE_BRACE     {: RESULT = new Literal.ArrayLit(el, new Terminal(bleft,bright)); :}
                    | OPEN_BRACE:b CLOSE_BRACE                       {: RESULT = new Literal.ArrayLit(new ArrayList<Expr>(), new Terminal(bleft,bright)); :};
primitiveLiteral  ::= INTEGER_LITERAL:n                              {: if (n.equals("9223372036854775808")) { throw new ParseError(new Token.StringToken(n, nleft, nright),file); }
                                                                        RESULT = new Literal.IntLit(Long.parseLong(n),new Terminal(nleft,nright)); :}
                    | CHARACTER_LITERAL:c                            {: RESULT = new Literal.CharLit(c,new Terminal(cleft,cright)); :}
                    | FALSE:o                                        {: RESULT = new Literal.BoolLit(false,new Terminal(oleft,oright)); :}
                    | TRUE:o                                         {: RESULT = new Literal.BoolLit(true,new Terminal(oleft,oright)); :}
                    | NULL:o                                         {: if (extension.equals("eta") || extension.equals("eti")) { throw new ParseError(new Token.StringToken(o, oleft, oright),file); }
                                                                        RESULT = new Literal.NullLit(new Terminal(oleft,oright)); :};
functionCall    ::= IDENTIFIER:id OPEN_PAREN exprList:vl CLOSE_PAREN {: RESULT = new Expr.FunctionCall(id, vl,new Terminal(idleft,idright));:} // these should be statements!
                    | IDENTIFIER:id OPEN_PAREN CLOSE_PAREN           {: RESULT = new Expr.FunctionCall(id, new ArrayList<>(),new Terminal(idleft,idright));:};
unop            ::= MINUS:u                                          {: RESULT = new ParseUtil.UnOpBundle(UnaryOp.Operation.NEG,new Terminal(uleft,uright)); :}  // cannot differentiate identical token but need diff prec
                    | NOT:u                                          {: RESULT = new ParseUtil.UnOpBundle(UnaryOp.Operation.NOT,new Terminal(uleft,uright)); :}; // need to take expr
binop           ::= expr:r PLUS:o expr:l                             {: RESULT = new BinaryOp(BinaryOp.Operation.PLUS,r,l,new Terminal(oleft,oright)); :}
                    | expr:r TIMES:o expr:l                          {: RESULT = new BinaryOp(BinaryOp.Operation.TIMES,r,l,new Terminal(oleft,oright)); :}
                    | expr:r MINUS:o expr:l                          {: RESULT = new BinaryOp(BinaryOp.Operation.MINUS,r,l,new Terminal(oleft,oright)); :}
                    | expr:r HIGHTIMES:o expr:l                      {: RESULT = new BinaryOp(BinaryOp.Operation.HIGHTIMES,r,l,new Terminal(oleft,oright)); :}
                    | expr:r DIVIDE:o expr:l                         {: RESULT = new BinaryOp(BinaryOp.Operation.DIVIDE,r,l,new Terminal(oleft,oright)); :}
                    | expr:r MODULO:o expr:l                         {: RESULT = new BinaryOp(BinaryOp.Operation.MODULO,r,l,new Terminal(oleft,oright)); :}
                    | expr:r LT:o expr:l                             {: RESULT = new BinaryOp(BinaryOp.Operation.LT,r,l,new Terminal(oleft,oright)); :}
                    | expr:r LEQ:o expr:l                            {: RESULT = new BinaryOp(BinaryOp.Operation.LEQ,r,l,new Terminal(oleft,oright)); :}
                    | expr:r GT:o expr:l                             {: RESULT = new BinaryOp(BinaryOp.Operation.GT,r,l,new Terminal(oleft,oright)); :}
                    | expr:r GEQ:o expr:l                            {: RESULT = new BinaryOp(BinaryOp.Operation.GEQ,r,l,new Terminal(oleft,oright)); :}
                    | expr:r EQB:o expr:l                            {: RESULT = new BinaryOp(BinaryOp.Operation.EQB,r,l,new Terminal(oleft,oright)); :}
                    | expr:r NEQB:o expr:l                           {: RESULT = new BinaryOp(BinaryOp.Operation.NEQB,r,l,new Terminal(oleft,oright)); :}
                    | expr:r AND:o expr:l                            {: RESULT = new BinaryOp(BinaryOp.Operation.AND,r,l,new Terminal(oleft,oright)); :}
                    | expr:r OR:o expr:l                             {: RESULT = new BinaryOp(BinaryOp.Operation.OR,r,l,new Terminal(oleft,oright)); :};
field           ::= indexable:idx PERIOD:p IDENTIFIER:idfl           {: if (extension.equals("eta") || extension.equals("eti")) { throw new ParseError(new Token.StringToken(p, pleft, pright),file); }
                                                                        RESULT = new Expr.Field(idx, idfl, new Terminal(idxleft, idxright)); :}
                    | field:f PERIOD:p IDENTIFIER:idfl               {: RESULT = new Expr.Field(f, idfl, new Terminal(fleft, fright)); :};
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Types */
primType        ::= BOOL:s                                           {: RESULT = new Primitive.BOOL(new Terminal(sleft,sright)); :}
                    | INT:s                                          {: RESULT = new Primitive.INT(new Terminal(sleft,sright)); :};
recordType      ::= IDENTIFIER:s                                     {: if (extension.equals("eta") || extension.equals("eti")) { throw new ParseError(new Token.StringToken(s, sleft, sright),file); }
                                                                        RESULT = new Type.RecordType(s, new Terminal(sleft,sright)); :};
type            ::= primType:pt                                      {: RESULT = pt; :}
                    | primType:pt OPEN_BRACKET CLOSE_BRACKET         {: RESULT = new Type.Array(pt); :}
                    | type:t OPEN_BRACKET CLOSE_BRACKET              {: RESULT = new Type.Array(t); :}
                    | recordType:t                                   {: RESULT = t; :};