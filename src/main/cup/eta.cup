import java_cup.runtime.*;
//import ast.*;

/* Preliminaries to set up and use the scanner.  */
//init with {: scanner.init();              :};
scan with {: return getScanner().next_token(); :};

/* Terminals */
terminal IDENTIFIER;
terminal STRING_LITERAL;
terminal CHARACTER_LITERAL;
terminal INTEGER_LITERAL;
terminal TRUE, FALSE;
terminal INT, BOOL;

terminal IF, ELSE, WHILE, RETURN, USE, LENGTH, PLUS, MINUS, TIMES, HIGHTIMES,
  DIVIDE, MODULO, NOT, LT, LEQ, GT, GEQ, AND, OR, EQUALS, EQB, NEQB,
  OPEN_BRACKET, CLOSE_BRACKET, OPEN_PAREN, CLOSE_PAREN, OPEN_BRACE, CLOSE_BRACE,
  COLON, COMMA, SEMICOLON, UNDERSCORE, UMINUS;

terminal INTERFACE, PROGRAM;

/* Nonterminals */
nonterminal file, interface, abs_meth, method, program, imports, use;
nonterminal defns, definition, decl, decls;
nonterminal assign, target, targets, type, typelst;
nonterminal statement, statementlst, if, while, fnblock, block, elseopt, semi;
nonterminal binop, unop, expr, fncall;
nonterminal return, vallst, bracketlst, nullbrackets, idxlst;

/* Precedences */
precedence left OR;
precedence left AND;
precedence left EQB, NEQB;
precedence left LT, LEQ, GT, GEQ;
precedence left PLUS, MINUS;
precedence left TIMES, HIGHTIMES, DIVIDE, MODULO;
precedence left UMINUS, NOT;
precedence left COMMA, OPEN_BRACKET, CLOSE_BRACKET, ELSE;

/* Grammar Definition */
//file            ::= INTERFACE interface {: System.out.println("got here"); :}
//                    | PROGRAM program;
//interface       ::= | abs_meth interface ;
start with program;

abs_meth        ::= IDENTIFIER OPEN_PAREN decls CLOSE_PAREN COLON typelst |
                    IDENTIFIER OPEN_PAREN decls CLOSE_PAREN |
                    IDENTIFIER OPEN_PAREN CLOSE_PAREN COLON typelst |
                    IDENTIFIER OPEN_PAREN CLOSE_PAREN;
program         ::= imports defns ;
imports          ::= use imports |
                     ;
use             ::= USE IDENTIFIER semi;
defns            ::= definition defns |
                    ;
decls           ::= decl |
                    decls COMMA decls;
decl            ::= IDENTIFIER COLON type;
assign          ::= targets EQUALS vallst;
definition      ::= method |
                    decl semi |
                    assign semi;
method          ::= abs_meth fnblock;
typelst         ::= type |
                    type COMMA typelst;
statementlst    ::= statement | statement statementlst;
if              ::= IF expr block elseopt |
                    IF OPEN_PAREN expr CLOSE_PAREN block elseopt;
while           ::= WHILE OPEN_PAREN expr CLOSE_PAREN block |
                    WHILE expr block;
fnblock         ::= OPEN_BRACE statementlst CLOSE_BRACE |
                    OPEN_BRACE statementlst return CLOSE_BRACE |
                    OPEN_BRACE return CLOSE_BRACE |
                    OPEN_BRACE CLOSE_BRACE;
block           ::= statement |
                    fnblock;
statement       ::= if |
                    while |
                    decl semi |
                    assign semi |
                    fncall semi;
fncall          ::= IDENTIFIER OPEN_PAREN vallst CLOSE_PAREN |
                    IDENTIFIER OPEN_PAREN CLOSE_PAREN;
elseopt         ::= | ELSE block;
unop            ::= MINUS %prec UMINUS | // cannot differentiate identical token but need diff prec
                    NOT;
binop           ::= PLUS |
                    MINUS |
                    TIMES |
                    HIGHTIMES |
                    DIVIDE |
                    MODULO |
                    LT |
                    LEQ |
                    GT |
                    GEQ |
                    EQB |
                    NEQB |
                    AND |
                    OR;
return          ::= RETURN semi |
                    RETURN vallst semi ;
vallst         ::= expr |
                    expr COMMA vallst;
type            ::= BOOL |
                    INT |
                    BOOL bracketlst |
                    INT bracketlst;
bracketlst      ::= nullbrackets |
                    OPEN_BRACKET INTEGER_LITERAL CLOSE_BRACKET |
                    OPEN_BRACKET INTEGER_LITERAL CLOSE_BRACKET bracketlst;
nullbrackets    ::= OPEN_BRACKET CLOSE_BRACKET |
                    OPEN_BRACKET CLOSE_BRACKET nullbrackets;
expr            ::= expr binop expr |
                    unop expr |
                    IDENTIFIER |
                    fncall |
                    STRING_LITERAL |
                    INTEGER_LITERAL:l |
                    CHARACTER_LITERAL |
                    FALSE |
                    TRUE |
                    OPEN_BRACE vallst CLOSE_BRACE |
                    IDENTIFIER idxlst |
                    LENGTH OPEN_PAREN expr CLOSE_PAREN;
idxlst          ::= OPEN_BRACKET expr CLOSE_BRACKET |
                    OPEN_BRACKET expr CLOSE_BRACKET idxlst;
target          ::= decl |
                    UNDERSCORE;
targets         ::= target |
                    target COMMA targets;
semi            ::= SEMICOLON |
                    ;
